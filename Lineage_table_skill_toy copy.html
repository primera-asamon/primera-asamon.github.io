<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <title>リネージュリマスター・スキル一覧</title>
    <meta name="description" content="">
    <meta name="keywords" content="">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.3/normalize.css">
    <!-- <link rel="stylesheet" href="normalize.css"> -->
    <!-- アイコンフォントの利用方法 http://fortawesome.github.io/Font-Awesome/ -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <!-- <link rel="stylesheet" href="font-awesome.min.css"> -->
    <link rel="stylesheet" href="Lineage_main.css">
    <link rel="stylesheet" href="Lineage_skill.css">
    <!-- <script src="jquery.min.js"></script> -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body id="top">
    <div class="nav">
        <ul class="nav-group">
            <li><a href="index.html">ホーム</a><i class="fa fa-home"></i></li>
            <li><a href="Lineage_table_monster.html">Monsters</a></li>
            <li><a href="Lineage_table_drop.html">Drops</a></li>
            <li><a href="Lineage_table_skill.html" class="active">&nbsp;Skills</a></li>
            <li><a href="LineageREMASTER_IME.html">IME</a></li>
            <li><a href="LineageREMASTER_ATOK.html">ATOK</a></li>
            <li><a href="LineageREMASTER_etc.html">諸表</a></li>
            <li><a href="font.html">大字</a></li>
            <li><a href="inkey_JAJP.html">押下釦</a></li>
        <li><a href="updates.html">変更歴</a></li>        </ul>
    </div>
<!-- ページ冒頭に非表示で読み上げ対応の国際化・説明テキスト -->
    <p id="screenreader-info" lang="en">
        This page lists MMORPG skills for Japanese-speaking players. It does not contain navigation or language switching. If you are using a screen reader or are not fluent in Japanese, please note that this page is for reference only and may not offer interactive support.
    </p>
<!-- 日本語でのページ説明（視認表示可） -->
    <p id="screenreader-info_jp" class="page-description">
        このページは日本語話者向けに設計されたMMORPGスキルの一覧表です。リンクやナビゲーション機能は設けておらず、ページ全体の内容を1ページで完結する構成になっています。内容の把握を主目的としています。
    </p>
<!-- 技術・魔法一覧のインポート(旧仕様)※スマホでは取得できないから 
 <input type="file" id="fileInput">
-->
<!-- 技術・魔法一覧のインポート(前仕様)※ファイル全体のペースト(長大なデータでは不適当) -->
<!-- <button id="submitBtn">表示</button>
     <div id="output"></div>
-->
<!-- 技術・魔法一覧のインポート(新仕様)※ファイル名のハードコーディング -->
    <button id="loadBtn">表示</button>
<!-- HTML（ボタンやセレクトボックスを追加） -->
    <div id="classFilterBtns" style="margin-bottom: 15px;">
        <button class="class-btn" data-cls="all">all</button>
        <button class="class-btn" data-cls="君">君</button>
        <button class="class-btn" data-cls="騎">騎</button>
        <button class="class-btn" data-cls="妖" data-elf="火">火</button>
        <button class="class-btn" data-cls="妖" data-elf="水">水</button>
        <button class="class-btn" data-cls="妖" data-elf="風">風</button>
        <button class="class-btn" data-cls="妖" data-elf="地">地</button>
        <button class="class-btn" data-cls="魔">魔</button><br>
        <button class="class-btn" data-cls="闇">闇</button>
        <button class="class-btn" data-cls="竜">竜</button>
        <button class="class-btn" data-cls="戦">戦</button>
        <button class="class-btn" data-cls="剣">剣</button>
        <button class="class-btn" data-cls="槍">槍</button>
        <button class="class-btn" data-cls="幻">幻</button>
        <button class="class-btn" data-cls="聖">聖</button>
        <button class="class-btn" data-cls="闘">闘</button> <!-- ファイターfighter -->
 <!-- スキル一覧のフィルタリングラジオボタン -->
        <label><input type="radio" name="matchType" value="only" checked> 完全一致</label>
        <label><input type="radio" name="matchType" value="includes"> 部分一致</label>
    </div>
<!-- 技術・魔法一覧の表示場所 ↓-->    
    <div id="result">
    </div>
<!-- 技術・魔法一覧の表示場所 ↑-->    
<!-- 脚注・権利表記 -->
    <div class="footer-text">
        <footer role="contentinfo">
            <section lang="ja">
                <h5 class="sr-only">著作権情報</h5>
                <small>当サイトで使用されているリネージュの画像・BGM及びその他の表現物の権利は下記のとおり権利者に帰属します：</small>
            </section>
            <section lang="en">
                <h5 class="sr-only">Copyright notice</h5>
                <small>Lineage and Lineage Eternal Life are registered trademarks of NCsoft Corporation.&copy;  1998-2011 Copyright NCsoft Corporation. NC Japan K.K. was granted by NCsoft Corporation the right to publish, distribute, and transmit Lineage Eternal Life in Japan. All Rights Reserved.</small>
            </section>
            <section lang="zh-TW">
                <h5 class="sr-only">版权声明</h5>
                <small>本頁面使用之《Lineage》相關素材，其版權皆屬原創作者所有。</small>
            </section>
        </footer>
    </div>
<!-- ページ上部にスクロールするボタン -->
<p>
    <a href="#top" class="btn-pagetop" aria-label="ページの先頭へ戻る">
        <i class="fa fa-arrow-up fa-2x" aria-hidden="true"></i>
        <span class="label-text">ページ先頭へ</span>
    </a>
</p>
<!-- FC2ではapplication/scriptでもjsファイル読み込み時にtext/htmlに変更され駆動しない。Javascript中にhtmlタグで開始される行がある場合誤認される。
対策：全ての行はhtml_pcv =+`～ではじめること。またはjs独立ファイルはあきらめる。 -->
<!--    <script src="lineage_skill.js" defer></script> -->
<script>
    let html_pcv = ''; // PC用レイアウト格納用
    let html_spv = ''; // スマホ用レイアウト格納用*未実装
// スクリプトの読み込みを待つためのDOMContentLoadedイベントリスナー
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM読み込み完了");
    });
// document.getElementById('fileInput').addEventListener('change', function(e) {
//スマホでは無理だからTSV選択はさせない。TSVファイル名のハードコーディング。
document.getElementById('loadBtn').addEventListener('click', function () {
    // 英文・日本語のスクリーンリーダー向け説明を非表示に
    const info_en = document.getElementById("screenreader-info");
    const info_jp = document.getElementById("screenreader-info_jp");

    if (!info_en.classList.contains("sr-only")) {
        info_en.classList.add("sr-only");
    }
    if (!info_jp.classList.contains("sr-only")) {
        info_jp.classList.add("sr-only");
    }

    // 告知文を非表示に
    const notice = document.getElementById("notice");
    if (notice) {
        notice.style.display = "none";
    }

    // url掃除。ページロード時をイベントとして処理するのは宿題。今は表示ボタンがトリガー。
// 表示されていない状態なのに #class=xxx があるならハッシュを消す
    if (!document.getElementById('result').innerHTML && location.hash.includes("class=")) {
        history.replaceState(null, null, location.pathname);
    }
// TSV読み込みと描画 タイムスタンプを附与したリクエストによる強制再読み込みによって、FC2Serverのキャッシュ寿命を回避。
    fetch('LineageREMASTER_skill3.tsv?v=' + new Date().getTime())
        .then(response => response.text())
        .then(text => {
//test用
// 読み込み成功時の処理
console.log("スクリプト開始");
console.log("DOM読み込み待機中");

function setup() {
  console.log("setup開始");

  const btn = document.getElementById('loadBtn');
  if (btn) {
    console.log("ボタン取得成功");
    btn.addEventListener('click', () => {
      console.log("ボタンクリック");
      fetch('LineageREMASTER_skill3.tsv?v=' + new Date().getTime())
        .then(response => {
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
          return response.text();
        })
        .then(text => {
          console.log("読み込み成功");
          document.getElementById('result').innerHTML = html_pcv;
//        document.getElementById('result').textContent = text;

//      DOM構築後に初期化処理を確実に実行
        requestAnimationFrame(() => {
            initializeTableBehavior();
        });

        })
        .catch(error => {
          console.error("読み込みエラー:", error);
        });
    });
  } else {
    console.log("loadBtn 見つからず");
  }
}
// DOMContentLoaded イベントを使用して、DOMの読み込み完了を待つ
if (document.readyState === 'loading') {
  console.log("DOM読み込み待機中");
  document.addEventListener('DOMContentLoaded', setup);
} else {
  console.log("DOMすでに構築済み、即時実行");
  setup();
}
    // [表示]ボタンを無効化＋グレーアウト
    const loadBtn = document.getElementById("loadBtn");
    if (loadBtn) {
        loadBtn.disabled = true;
        loadBtn.style.opacity = "0.5";
        loadBtn.style.cursor = "not-allowed";
        loadBtn.title = "クラス選択時に自動表示されるため、このボタンは不要です。";
    }
// ここにTSVパース＆表示処理を書く
        const lines = text.trim().split('\n');
        let html_pcv = `<table>`;
// filter_header
    // <!-- data-control fieldごとに処理区分を設定する 
    //sort：ソートアイコンボタンと文字列としての並び替え
    //number：ソートアイコンボタンと数値としての並び替え
    //refine：フィルターアイコンボタンとクリックによるダイアログフォーム表示
    //checklist：ダイアログフォームにチェックボックス付リストアイテムを表示する
    //--> 
// No.とLevelとスキル名はtheaderでは使用しない。1+1+9=11列。
          html_pcv += `<tbody id="filter_header" class="record-table" data-cls="君騎妖魔闇竜戦剣槍幻聖" data-elf="共">`
          html_pcv += `<tr class="record-title">
            <th class="col-data_no">No.</th>
            <th class="col-data_level">Lv.</th>
            <th class="col-data_skillname" colspan="9">フィルター</th>
          </tr>`
            // skill_domain_tendency:2+2+2=6列
          html_pcv += `<tr>
            <th class="col-header" colspan="5">習得クラス</th>
            <th class="col-header" data-control="sort refine checklist" colspan="2">活性</th>
            <th class="col-header" data-control="sort refine checklist" colspan="2">種類</th>
            <th class="col-header" data-control="sort refine checklist" colspan="2">性向</th>
          </tr>`
            // skill_domain_resource:2+2+3+2+2=11列
          html_pcv += `<tr>
            <th class="col-header" data-control="sort number" colspan="2">消耗MP</th>
            <th class="col-header" data-control="sort number" colspan="2">消耗HP</th>
            <th class="col-header" colspan="3">材料・触媒</th>
            <th class="col-header" data-control="sort refine checklist" colspan="2">装備条件</th>
            <th class="col-header" colspan="2">持続時間</th>
          </tr>`
            // skill_domain_effect:3+2+6=11列
          html_pcv += `<tr>
            <th class="col-header" colspan="3">対象</th>
            <th class="col-header" colspan="2">再使用時間</th>
            <th class="col-header" colspan="6">効果・性能</th>
          </tr>`
            // skill_domain_acquisition:2+3+6=11列
          html_pcv += `<tr>
            <th class="col-header" colspan="2">習得Lv.</th>
            <th class="col-header" data-control="sort refine checklist" colspan="3">取得方法</th>
            <th class="col-header" colspan="6">価格</th>
          </tr>`
            // skill_domain_dropmob:11列
          html_pcv += `<tr>
            <th class="col-header" colspan="11">ドロップ</th>
          </tr>`
            // skill_domain_dropmob:11列
          html_pcv += `<tr>
            <th class="col-header" colspan="11">【蘇生】</th>
          </tr>`
            // skill_domain_notes:6+5=11列
          html_pcv += `<tr>
            <th class="col-header" colspan="6">備考1</th>
            <th class="col-header" colspan="5">備考2</th>
          </tr>`
          html_pcv +=`</tbody>`
// table全体のheader
        for (const line of lines) {
            const fields = line.split('\t');
            console.log(`フィールド数(${line}):`, fields.length); // フィールド数を確認

            if (fields.length < 25) {
                console.warn("データ不足:", fields);
                continue; // フィールド数が不足している場合スキップ
            }
// 各フィールドの値を変数に格納
            const [no,img,level,name,cls,elf,active,type,align,mp,hp,material,gear,duration,target,reuse,effect,acqLv,obtain,price,Droporigin,Dropcomp,note1,note2,EOR] = line.split('\t');
            // 各フィールドをTAB分割 EOR(End Of Record)を無視
            // imgは画像のURLだが、ここでは使用しないので無視。値は"全角Space"
            // EORは行の終わりを示すが、ここでは使用しないので無視。値は"■"

            // clsとelfのまとめ表示
            let clsDisplay = cls;
            if (cls === "妖" && elf) {
                clsDisplay += `（${elf}）`;
            };
            html_pcv += `<tbody id="(${name})" class="record-table" data-cls=${cls} data-elf=${elf}>`;
            // No.とLevelとスキル名は「<th>～」を使用しない。1+1+9=11列。
                html_pcv += `<tr class="record-title">
                            <td class="col-data_no">No.${no}</td>`
                // 等級・スキルレベルの出力部分
                            if (/^\d+$/.test(level)) {
                    // 数字のみの場合
                                html_pcv += `<td class="col-data_level">Lv.${level}</td>`;
                            } else {
                    // 空または文字列（神話・伝説など）の場合
                                html_pcv += `<td class="col-data_level">${level}</td>`;
                            }   
            html_pcv += `<td class="col-data_skillname" colspan="9">${name}</td>
                        </tr>`
            // skill_domain_eligible_character:5列
            // skill_domain_tendency:2+2+2=6列
                html_pcv += `<tr>
                            <th class="col-header">習得クラス</th><td class="col-data" colspan="4">${clsDisplay}</td>`
                html_pcv += `<th class="col-header">活性</th><td class="col-data">${active}</td>
                            <th class="col-header">種類</th><td class="col-data">${type}</td>
                            <th class="col-header">性向</th><td class="col-data">${align}</td>
                        </tr>`
            // skill_domain_resource:2+2+3+2+2=11列
                html_pcv += `<tr>
                            <th class="col-header">消耗MP</th><td class="col-data">${mp}</td>
                            <th class="col-header">消耗HP</th><td class="col-data">${hp}</td>
                            <th class="col-header">材料・触媒</th><td class="col-data" colspan="2">${material}</td>
                            <th class="col-header">装備条件</th><td class="col-data">${gear}</td>
                            <th class="col-header">持続時間</th><td class="col-data">${duration}</td>
                        </tr>`
            // skill_domain_effect:3+2+6=11列
                html_pcv += `<tr>
                            <th class="col-header">対象</th><td class="col-data" colspan="2">${target}</td>
                            <th class="col-header">再使用時間</th><td class="col-data">${reuse}</td>
                            <th class="col-header">効果・性能</th><td class="col-data" colspan="5">${effect}</td>
                        </tr>`
            // skill_domain_acquisition:2+3+6=11列
                html_pcv += `<tr>
                            <th class="col-header">習得Lv.</th><td class="col-data">${acqLv}</td>
                            <th class="col-header">取得方法</th><td class="col-data" colspan="2">${obtain}</td>
                            <th class="col-header">価格</th><td class="col-data" colspan="5">${price}</td>
                        </tr>`
            // skill_domain_dropmob:11列
                html_pcv += `<tr>
                            <th class="col-header">ドロップ</th><td class="col-data" colspan="11">${Droporigin}</td>
                        </tr>`
            // skill_domain_dropmob:11列
                html_pcv += `<tr>
                            <th class="col-header">【蘇生】</th><td class="col-data" colspan="11">${Dropcomp}</td>
                        </tr>`
            // skill_domain_notes:6+5=11列
                html_pcv += `<tr>
                            <th class="col-header">備考1</th><td class="col-data" colspan="5">${note1}</td>
                            <th class="col-header">備考2</th><td class="col-data" colspan="4">${note2}</td>
                        </tr>`
            html_pcv +=`</tbody>`
        }
        html_pcv += `</table>`;
                document.getElementById('result').innerHTML = html_pcv;
// テーブル描画後
// クラスフィルタリングの初期化
        document.querySelectorAll('.class-btn').forEach(btn => {
            btn.classList.remove('active'); // すべてのボタンからアクティブクラスを削除
        });
// 初期状態で「all」ボタンをアクティブにする
document.querySelector('.class-btn[data-cls="all"]').classList.add('active');
// tbodyごとに初期表示を設定（record-titleのみ表示）
document.querySelectorAll('tbody.record-table').forEach(tbody => {
    const isTarget = tbody.dataset.cls === 'all';
    tbody.dataset.collapsed = isTarget ? 'false' : 'true';
// 各クラス毎の表示非表示判定は？
    console.log(`tbody ${tbody.dataset.cls} → collapsed=${tbody.dataset.collapsed}`);

    tbody.querySelectorAll('tr').forEach(tr => {
        const isTitle = tr.classList.contains('record-title');
        tr.style.display = (isTarget || isTitle) ? '' : 'none';
// isTitle=true？それともrecord-titleでない行がtrueなの？
        const text = tr.textContent.trim().slice(0, 10);
        console.log(`tr: "${text}", isTitle: ${isTitle}`);
    });
});
// 各ボタンにクリックイベントリスナーを追加
document.querySelectorAll('.class-btn').forEach(btn => {
    btn.addEventListener('click', function () {
        // アクティブクラスの切り替え
        document.querySelectorAll('.class-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        const selectedCls = this.dataset.cls;
        const selectedElf = this.dataset.elf || '';
        const matchType = document.querySelector('input[name="matchType"]:checked').value;
        // tbodyごとにフィルタリング
        document.querySelectorAll('tbody.record-table').forEach(tbody => {
            const cls = tbody.dataset.cls || '';
            const elf = tbody.dataset.elf || '';
        // 初期値isMatchはfalse＝非表示
            let isMatch = false;
            if (selectedCls === 'all') {
                isMatch = true;
        // ラジオボタンの選択状態
            } else if (matchType === 'only') {
        // 完全一致モード
                if (selectedCls === '妖') {
                    isMatch =
                        (cls === '妖') &&
                        (elf === selectedElf || elf === '共');
                } else {
                    isMatch = cls === selectedCls;
                }
            } else {
        // 部分一致モード
                if (selectedCls === '妖') {
                    isMatch =
                        cls.includes('妖') &&
                        (elf === selectedElf || elf === '共');
                } else {
                    isMatch = cls.includes(selectedCls);
                }
            }
            tbody.dataset.collapsed = 'true'; // 既定：折りたたみ
            tbody.querySelectorAll('tr').forEach(tr => {
                    // 一致するクラスのみ表示、そうでなければ完全非表示
                const isTitle = tr.classList.contains('record-title');
                tr.style.display = isMatch && isTitle ? '' : 'none';
            });
        });
    });
});
// タイトル行クリックで展開／折りたたみ切り替え
document.querySelectorAll('.record-title').forEach(titleRow => {
    titleRow.addEventListener('click', function () {
        const tbody = this.closest('tbody');
        const isCollapsed = tbody.dataset.collapsed === 'true';

        tbody.dataset.collapsed = isCollapsed ? 'false' : 'true';

        tbody.querySelectorAll('tr').forEach(tr => {
            const isTitle = tr.classList.contains('record-title');
            tr.style.display = isCollapsed || isTitle ? '' : 'none';
        });
    });
});
// クラスコードマップ(url用/数字は公式webページのClassID)
const classCodeMap = {
//  "全": "all"   //-/全クラスallクラスとして設定しない。未定義として全件表示扱い。
  "君": "pri",  //0/君主prince・princess
  "騎": "kni",  //1/ナイトknight
  "妖": "elf",  //2/エルフelf
  "魔": "wiz",  //3/ウィザードwizard
  "闇": "dak",  //4/ダークエルフdarkelf
  "竜": "dra",  //5/ドラゴンナイトdragonknight
  "幻": "ill",  //6/イリュージョニストillusionist
  "戦": "war",  //7/ウォリアーwarrior
  "剣": "fen",  //8/フェンサーFencer
  "槍": "lan",  //9/ランサーlancer
  "聖": "Pal",  //10/パラディンPaladin
  "闘": "fig"   //11/ファイターfighter
};
// クラスコード取得関数
function getClassCode(label) {
  return classCodeMap[label] || "all"; // 未定義なら仮のフォールバック
}// クラスフィルタリング関数
document.querySelectorAll('.class-btn').forEach(btn => {
    btn.addEventListener('click', function () {
        const label = this.dataset.cls; // たとえば "聖"
        const code = getClassCode(label); // たとえば "hol"
        history.replaceState(null, null, `#class=${code}`);
//        filterByClass(code); // 既存の注出関数
    });
});
    // reader.readAsText(e.target.files[0], 'UTF-8');
    // console.log(text); // デバッグ用・341件24フィールドは冗長。
        })
        .catch(error => {
            document.getElementById('result').textContent = '読み込み失敗: ' + error;
        });
    // ここでaddEventListenerの関数を閉じる

// イベントリスナーの再登録を含めた初期化関数↓ここから
function initializeTableBehavior() {
  console.log("🔁 initializeTableBehavior 実行");
  document.querySelectorAll('tbody.record-table').forEach(tbody => {
    const isTarget = tbody.dataset.cls === 'all';
    tbody.dataset.collapsed = isTarget ? 'false' : 'true';
    console.log(`tbody ${tbody.dataset.cls} → collapsed=${tbody.dataset.collapsed}`);
    tbody.querySelectorAll('tr').forEach(tr => {
      const isTitle = tr.classList.contains('record-title');
      tr.style.display = (isTarget || isTitle) ? '' : 'none';
    });
  });
  document.querySelectorAll('tr.record-title').forEach(titleRow => {
    titleRow.addEventListener('click', function () {
      const tbody = this.closest('tbody');
      const isCollapsed = tbody.dataset.collapsed === 'true';
      tbody.dataset.collapsed = isCollapsed ? 'false' : 'true';
      console.log(`トグル: ${tbody.dataset.cls} → ${tbody.dataset.collapsed}`);
      tbody.querySelectorAll('tr').forEach(tr => {
        const isTitle = tr.classList.contains('record-title');
        tr.style.display = isCollapsed || isTitle ? '' : 'none';
      });
    });
  });
}
// イベントリスナーの再登録を含めた初期化関数↑ここまで
});

function scrollToFirstRecord() {
  var table = document.querySelector("table");
  var tbody = table.getElementsByTagName("tbody")[0];
  var firstRow = tbody.getElementsByTagName("tr")[0];
  firstRow.scrollIntoView({ behavior: 'smooth', block: 'start' });
  // ヘッダーの高さを取得
  var headerHeight = table.querySelector("thead.sticky").offsetHeight; //80pxを取得Edgeコンソールより確認
  // スクロール位置を調整して1件目の行が見えるようにする
  var firstRowTop = firstRow.getBoundingClientRect().top - document.body.getBoundingClientRect().top;
  window.scrollTo({ top: firstRowTop - headerHeight, behavior: 'smooth' });
}

/* ── 関数：初期化 ── */
tblcontrol.init =()=> {
  //─] コントロール追加
  document.querySelectorAll( "tbody th[data-control]" ).forEach( th => {
  //─]─] 取得
  const index = th.cellIndex;
  const table = th.closest( "table" );
  const tbody = table.querySelector( "tbody" );

  //─]─] コントロール
  const control = th.appendChild( document.createElement( "div" ) );
  control.classList.add( "tbl-control" );

  //─]─]─] ソート
  if( /sort/.test( th.dataset.control ) ){
  //─]─]─]─] 昇順ボタン
  const ascend = control.appendChild( document.createElement( "button" ) );
  ascend.dataset.type = "sort-ascend";
  ascend.appendChild( tblcontrol.btnicon.ascend.cloneNode( true ) );
  //─]─]─]─] 降順ボタン
  const descend = control.appendChild( document.createElement( "button" ) );
  descend.dataset.type = "sort-descend";
  descend.appendChild( tblcontrol.btnicon.descend.cloneNode( true ) );
  //─]─]─]─] イベントハンドラ
  ascend.onclick = descend.onclick = tblcontrol.sort;
  }

  //─]─]─] 絞込み
  if( /refine/.test( th.dataset.control ) ){
  //─]─]─]─] ボタン
  const refine = control.appendChild( document.createElement( "button" ) );
  refine.dataset.type = "refine";
  refine.appendChild( tblcontrol.btnicon.refine.cloneNode( true ) );
  refine.onclick = tblcontrol.toggleFilter;

  //─]─]─]─] フィルター
  const filter = control.appendChild( document.createElement( "form" ) );
  filter.classList.add( "tbl-filter" );
  filter.onsubmit = tblcontrol.refine;
  filter.onreset = tblcontrol.unrefine;

  //─]─]─]─]─] 全選択
  let div = filter.appendChild( document.createElement( "div" ) );
  div.classList.add( "tbl-filter-all" );
  let label = div.appendChild( document.createElement( "label" ) );
  let input = label.appendChild( document.createElement( "input" ) );
  input.name = "filter_all";
  input.type = "checkbox";
  input.checked = true;
  input.onchange = tblcontrol.checkAll;
  label.appendChild( document.createTextNode( "すべて" ) );

  // index: フィルター対象列のインデックス
  // th: index番目のth要素
  const th = table.querySelectorAll('th')[index];
  const controlValue = th.dataset.control || "";

  // checklistが含まれているか判定
  const isChecklist = controlValue.split(/\s+/).includes("checklist");

  //─]─]─]─]─] キーアイテム
  div = filter.appendChild( document.createElement( "div" ) );
  div.classList.add( "tbl-filter-inventory" );
  if (isChecklist) {
    div.style.display = "block";
  }else{
    div.style.display = "none";
  }
  const list = [].reduce.call( tbody.rows, ( arr, row ) => {
    const text = row.cells[ index ].textContent;
    if( ! arr.includes( text ) ){ arr.push( text ) }
    return arr;
  }, [] );
  list.forEach( text => {
    label = div.appendChild( document.createElement( "label" ) );
    input = label.appendChild( document.createElement( "input" ) );
    input.name = "filter_item";
    input.type = "checkbox";
    input.value = text;
    input.checked = true;
    input.onchange = tblcontrol.checkAll;
    label.appendChild( document.createTextNode( text ) );
  } );
  filter.dataset.keyitem = JSON.stringify( list );

  //─]─]─]─]─] キーワード
  div = filter.appendChild( document.createElement( "div" ) );
  div.classList.add( "tbl-filter-keyword" );
  input = div.appendChild( document.createElement( "input" ) );
  input.name = "filter_keyword";
  input.type = "text";
  input.placeholder = "絞込みワード";
  input.style.width = "160px";
  filter.dataset.keyword = "";

  /* ↓　textbox → min/max 2025-08-17*/

  //─]─]─]─]─] min/max（数値列のみ）
  if (/number/.test(th.dataset.control)) {
    div = filter.appendChild(document.createElement("div"));
    div.classList.add("tbl-filter-range");

    input = div.appendChild(document.createElement("input"));
    input.name = "min";
    input.type = "number";
    input.placeholder = "最小";
    input.style.width = "72px";
    input.className = "tbl-filter-minmax";

    input = div.appendChild(document.createElement("input"));
    input.name = "max";
    input.type = "number";
    input.placeholder = "最大";
    input.style.width = "72px";
    input.className = "tbl-filter-minmax";
  }

  /* ↑　textbox → min/max */

  //─]─]─]─]─] 各ボタン
  div = filter.appendChild( document.createElement( "div" ) );
  div.classList.add( "tbl-filter-buttons" );

  input = div.appendChild( document.createElement( "input" ) );
  input.type = "submit";
  input.value = "絞込み";

  input = div.appendChild( document.createElement( "input" ) );
  input.type = "reset";
  input.value = "クリア";

  input = div.appendChild( document.createElement( "input" ) );
  input.type = "button";
  input.value = "メニュー閉じる";
  input.onclick = tblcontrol.toggleFilter;
  }
  } );
// ↓debugCode
//  document.querySelectorAll("thead th[data-control]").forEach(th => {
//    console.log("対象列:", th.textContent.trim(), "属性:", th.dataset.control);
//  });
// ↑debugCode
};

/* ── 関数：並び替え ── */
tblcontrol.sort = evt => {
//─] HTML 要素
const target = evt.target;
const thead = target.closest( "thead" );
const th = target.closest( "th" );
const tbody = target.closest( "table" ).querySelector( "tbody" );
//─] 列番号
const index = th.cellIndex;
//─] ソート方法
const type = target.dataset.type;
const numsort = /number/.test( th.dataset.control );
//─] ソート
Array.from( tbody.rows ).sort( ( row1, row2 ) => {
const [ a, b ] = [
row1.cells[ index ].textContent,
row2.cells[ index ].textContent
].map( value => numsort ? Number( value ) : value );
return a==b ? 0 :
type=="sort-ascend" ? ( a>b ? 1 : -1 ) : ( a>b ? -1 : 1 ) ;
} ).forEach( row => tbody.appendChild( row ) );
//─] ボタンの色
thead.querySelectorAll( "button[ data-type|='sort' ]" ).
forEach( button => button.classList[ button==target ? "add" : "remove" ]( "filter" ) );
};

/* ── 関数：フィルター開閉 ── */
tblcontrol.toggleFilter = evt => {
//─] HTML 要素
const target = evt.target.closest( ".tbl-control" ).querySelector( ".tbl-filter" );
const filters = target.closest( "thead" ).querySelectorAll( ".tbl-filter" );
//─] 開閉フラグ
const open = ! target.classList.contains( "open" );
//─] すべてのフィルターを閉じる
filters.forEach( filter => {
//──] リセット：キーアイテム
const keyitem = JSON.parse( filter.dataset.keyitem );
filter.filter_item.forEach(
item => item.checked = keyitem.includes( item.value )
);
filter.filter_all.checked = Array.from( filter.filter_item ).every( item => item.checked ) ;
//──] リセット：キーワード
const keyword =
filter.filter_keyword.value = filter.dataset.keyword;
//──] ボタンの色
filter.closest( "th" ).
querySelector( "button[ data-type='refine' ]" ).
classList[ ( ! keyword ) && filter.filter_all.checked ? "remove" : "add" ]( "filter" );
//──] 閉じる
filter.classList.remove( "open" );
} );
//─] フィルターを開く
if( open ) target.classList.add( "open" );
};

/* ── 関数：全選択 ── */
tblcontrol.checkAll = evt => {
const target = evt.target;
const filter = target.form;
target.name=="filter_all" ?
Array.from( filter.filter_item ).forEach( item => item.checked = target.checked ) :
filter.filter_all.checked = Array.from( filter.filter_item ).every( item => item.checked ) ;
};

/* ── 関数：絞込み ── */
/* ↓　textbox → min/max */

//-] 関数数値範囲での絞り込み

tblcontrol.refine = function(event) {
  event.preventDefault();

  const form = event.target;
  const th = form.closest("th");
  const colIndex = th.cellIndex;
  const rows = th.closest("table").tBodies[0].rows;

  // 絞り込み条件取得（意味保証された属性から）
  const controlValue = th.dataset.control ?? "";
  const isNumber = controlValue.split(/\s+/).includes("number");
//  console.log(controlValue, isNumber, th.dataset.control); // ← デバッグ用

  const min = isNumber ? parseFloat(form.min?.value) : undefined;
  const max = isNumber ? parseFloat(form.max?.value) : undefined;
  const keyword = form.filter_keyword?.value?.trim();

  // keyitem（チェックボックス）取得
  const keyitem = form.filter_item
    ? Array.from(form.filter_item).filter(input => input.checked).map(input => input.value)
    : [];
  form.dataset.keyitem = JSON.stringify(keyitem);

  // 行ごとに絞り込み判定
  for (const row of rows) {
    const cell = row.cells[colIndex];
    const text = cell.textContent.trim();
    let show = true;

  // チェックボックスによる絞り込み
    if (keyitem.length > 0 && !keyitem.includes(text)) {
    show = false;
  }

    if (isNumber) {
      const value = parseFloat(text);
      if (!isNaN(min) && value < min) show = false;
      if (!isNaN(max) && value >= max) show = false;

      // キーワードでの数値絞り込み完全一致
      if (keyword && text !== keyword) show = false;
    } else {
      // キーワードでの文字列絞り込み部分一致
      if (keyword && !text.includes(keyword)) show = false;
    }

    row.style.display = show ? "" : "none";
  }
};

/* ── スタイルシート ── */
//─] オブジェクト
tblcontrol.stylesheet =
document.querySelector( "head" ).
appendChild( document.createElement( "style" ) ).sheet;
//─] 関数
tblcontrol.css =( selector, style )=> {
const sheet = tblcontrol.stylesheet;
sheet.insertRule( `${ selector } { ${ style } }`, sheet.cssRules.length );
};
//─] 設定
//─]─] コントロール
tblcontrol.css( "th[ data-control ] .tbl-control", `
position: relative;
text-align: center;
` );
tblcontrol.css( "th[ data-control ] .tbl-control > button", `
width: 16px;
height: 16px;
padding: 0px;
margin: 2px;
border: solid 1px #ccc;
background: #eee;
cursor: pointer;
outline: none !important;
` );
tblcontrol.css( "th[ data-control ] .tbl-control > button:hover", `
border-color: #666;
` );
tblcontrol.css( "th[ data-control ] .tbl-control > button:active", `
background: #fff;
` );
tblcontrol.css( "th[ data-control ] .tbl-control button.filter", `
border-color: #fc6;
background: #ffc;
` );
tblcontrol.css( "th[ data-control ] .tbl-control button img", `
width: 100%; height: 100%;
border: none;
pointer-events: none;
` );
//─]─] フィルター
tblcontrol.css( "th[ data-control ] .tbl-filter", `
position: absolute; left: 0px; top: 100%; z-index: 100;
display: none;
box-sizing: border-box;
width: 200px;
padding: 4px;
margin: 0px;
border: solid 1px #ccc;
background: #ffe;
` );
tblcontrol.css( "th[ data-control ] .tbl-filter.open", `
display: block;
` );
tblcontrol.css( "th[ data-control ] .tbl-filter label", `
display: block;
text-align: left;
` );
tblcontrol.css( "th[ data-control ] .tbl-filter-inventory", `
max-height: 200px;
overflow: auto;
` );
tblcontrol.css( "th[ data-control ] .tbl-filter-keyword", `
margin: 4px auto;
` );
tblcontrol.css( "th[ data-control ] .tbl-filter-buttons input", `
box-sizing: border-box;
width: 164px;
margin: 2px;
` );
tblcontrol.css( `
th[ data-control ] .tbl-filter-buttons input[ value="絞込み" ],
th[ data-control ] .tbl-filter-buttons input[ value="クリア" ],
th[ data-control ] .tbl-filter-range input[ name="min" ],
th[ data-control ] .tbl-filter-range input[ name="max" ]
`, `
width: 80px;
margin: 2px;
` );

/* ── ボタンアイコン ── */
tblcontrol.btnicon = new Object();
//─] ソート：昇順
tblcontrol.btnicon.ascend = new Image();
tblcontrol.btnicon.ascend.src = `data:image/svg+xml;charset=utf-8,
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
<polygon fill="%23666" stroke="none" points="8,3 3,11 13,11" />
</svg>`;
//─] ソート：降順
tblcontrol.btnicon.descend = new Image();
tblcontrol.btnicon.descend.src = `data:image/svg+xml;charset=utf-8,
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
<polygon fill="%23666" stroke="none" points="8,13 3,5 13,5" />
</svg>`;
//─] 絞込み
tblcontrol.btnicon.refine = new Image();
tblcontrol.btnicon.refine.src = `data:image/svg+xml;charset=utf-8,
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
<polygon fill="%23666" stroke="none" points="8,11 3,3 13,3" />
<rect fill="%23666" stroke="none" x="6" y="6" width="4" height="6" />
</svg>`;

/* ── 関数：初期化 ── */
tblcontrol.init =()=> {
  //─] コントロール追加
  document.querySelectorAll( "th[ data-control ]" ).forEach( th => {
  //─]─] 取得
  const index = th.cellIndex;
  const table = th.closest( "table" );
  const tbody = table.querySelector( "tbody" );

  //─]─] コントロール
  const control = th.appendChild( document.createElement( "div" ) );
  control.classList.add( "tbl-control" );

  //─]─]─] ソート
  if( /sort/.test( th.dataset.control ) ){
  //─]─]─]─] 昇順ボタン
  const ascend = control.appendChild( document.createElement( "button" ) );
  ascend.dataset.type = "sort-ascend";
  ascend.appendChild( tblcontrol.btnicon.ascend.cloneNode( true ) );
  //─]─]─]─] 降順ボタン
  const descend = control.appendChild( document.createElement( "button" ) );
  descend.dataset.type = "sort-descend";
  descend.appendChild( tblcontrol.btnicon.descend.cloneNode( true ) );
  //─]─]─]─] イベントハンドラ
  ascend.onclick = descend.onclick = tblcontrol.sort;
  }

  //─]─]─] 絞込み
  if( /refine/.test( th.dataset.control ) ){
  //─]─]─]─] ボタン
  const refine = control.appendChild( document.createElement( "button" ) );
  refine.dataset.type = "refine";
  refine.appendChild( tblcontrol.btnicon.refine.cloneNode( true ) );
  refine.onclick = tblcontrol.toggleFilter;

  //─]─]─]─] フィルター
  const filter = control.appendChild( document.createElement( "form" ) );
  filter.classList.add( "tbl-filter" );
  filter.onsubmit = tblcontrol.refine;
  filter.onreset = tblcontrol.unrefine;

  //─]─]─]─]─] 全選択
  let div = filter.appendChild( document.createElement( "div" ) );
  div.classList.add( "tbl-filter-all" );
  let label = div.appendChild( document.createElement( "label" ) );
  let input = label.appendChild( document.createElement( "input" ) );
  input.name = "filter_all";
  input.type = "checkbox";
  input.checked = true;
  input.onchange = tblcontrol.checkAll;
  label.appendChild( document.createTextNode( "すべて" ) );

  // index: フィルター対象列のインデックス
  // th: index番目のth要素
  const th = table.querySelectorAll('th')[index];
  const controlValue = th.dataset.control || "";

  // checklistが含まれているか判定
  const isChecklist = controlValue.split(/\s+/).includes("checklist");

  //─]─]─]─]─] キーアイテム
  div = filter.appendChild( document.createElement( "div" ) );
  div.classList.add( "tbl-filter-inventory" );
  if (isChecklist) {
    div.style.display = "block";
  }else{
    div.style.display = "none";
  }
  const list = [].reduce.call( tbody.rows, ( arr, row ) => {
    const text = row.cells[ index ].textContent;
    if( ! arr.includes( text ) ){ arr.push( text ) }
    return arr;
  }, [] );
  list.forEach( text => {
    label = div.appendChild( document.createElement( "label" ) );
    input = label.appendChild( document.createElement( "input" ) );
    input.name = "filter_item";
    input.type = "checkbox";
    input.value = text;
    input.checked = true;
    input.onchange = tblcontrol.checkAll;
    label.appendChild( document.createTextNode( text ) );
  } );
  filter.dataset.keyitem = JSON.stringify( list );

  //─]─]─]─]─] キーワード
  div = filter.appendChild( document.createElement( "div" ) );
  div.classList.add( "tbl-filter-keyword" );
  input = div.appendChild( document.createElement( "input" ) );
  input.name = "filter_keyword";
  input.type = "text";
  input.placeholder = "絞込みワード";
  input.style.width = "160px";
  filter.dataset.keyword = "";

  /* ↓　textbox → min/max 2025-08-17*/

  //─]─]─]─]─] min/max（数値列のみ）
  if (/number/.test(th.dataset.control)) {
    div = filter.appendChild(document.createElement("div"));
    div.classList.add("tbl-filter-range");

    input = div.appendChild(document.createElement("input"));
    input.name = "min";
    input.type = "number";
    input.placeholder = "最小";
    input.style.width = "72px";
    input.className = "tbl-filter-minmax";

    input = div.appendChild(document.createElement("input"));
    input.name = "max";
    input.type = "number";
    input.placeholder = "最大";
    input.style.width = "72px";
    input.className = "tbl-filter-minmax";
  }

  /* ↑　textbox → min/max */

  //─]─]─]─]─] 各ボタン
  div = filter.appendChild( document.createElement( "div" ) );
  div.classList.add( "tbl-filter-buttons" );

  input = div.appendChild( document.createElement( "input" ) );
  input.type = "submit";
  input.value = "絞込み";

  input = div.appendChild( document.createElement( "input" ) );
  input.type = "reset";
  input.value = "クリア";

  input = div.appendChild( document.createElement( "input" ) );
  input.type = "button";
  input.value = "メニュー閉じる";
  input.onclick = tblcontrol.toggleFilter;
  }
  } );
// ↓debugCode
//  document.querySelectorAll("thead th[data-control]").forEach(th => {
//    console.log("対象列:", th.textContent.trim(), "属性:", th.dataset.control);
//  });
// ↑debugCode
};

/* ── 関数：並び替え ── */
tblcontrol.sort = evt => {
//─] HTML 要素
const target = evt.target;
const thead = target.closest( "thead" );
const th = target.closest( "th" );
const tbody = target.closest( "table" ).querySelector( "tbody" );
//─] 列番号
const index = th.cellIndex;
//─] ソート方法
const type = target.dataset.type;
const numsort = /number/.test( th.dataset.control );
//─] ソート
Array.from( tbody.rows ).sort( ( row1, row2 ) => {
const [ a, b ] = [
row1.cells[ index ].textContent,
row2.cells[ index ].textContent
].map( value => numsort ? Number( value ) : value );
return a==b ? 0 :
type=="sort-ascend" ? ( a>b ? 1 : -1 ) : ( a>b ? -1 : 1 ) ;
} ).forEach( row => tbody.appendChild( row ) );
//─] ボタンの色
thead.querySelectorAll( "button[ data-type|='sort' ]" ).
forEach( button => button.classList[ button==target ? "add" : "remove" ]( "filter" ) );
};

/* ── 関数：フィルター開閉 ── */
tblcontrol.toggleFilter = evt => {
//─] HTML 要素
const target = evt.target.closest( ".tbl-control" ).querySelector( ".tbl-filter" );
const filters = target.closest( "thead" ).querySelectorAll( ".tbl-filter" );
//─] 開閉フラグ
const open = ! target.classList.contains( "open" );
//─] すべてのフィルターを閉じる
filters.forEach( filter => {
//──] リセット：キーアイテム
const keyitem = JSON.parse( filter.dataset.keyitem );
filter.filter_item.forEach(
item => item.checked = keyitem.includes( item.value )
);
filter.filter_all.checked = Array.from( filter.filter_item ).every( item => item.checked ) ;
//──] リセット：キーワード
const keyword =
filter.filter_keyword.value = filter.dataset.keyword;
//──] ボタンの色
filter.closest( "th" ).
querySelector( "button[ data-type='refine' ]" ).
classList[ ( ! keyword ) && filter.filter_all.checked ? "remove" : "add" ]( "filter" );
//──] 閉じる
filter.classList.remove( "open" );
} );
//─] フィルターを開く
if( open ) target.classList.add( "open" );
};

/* ── 関数：全選択 ── */
tblcontrol.checkAll = evt => {
const target = evt.target;
const filter = target.form;
target.name=="filter_all" ?
Array.from( filter.filter_item ).forEach( item => item.checked = target.checked ) :
filter.filter_all.checked = Array.from( filter.filter_item ).every( item => item.checked ) ;
};

/* ── 関数：絞込み ── */
/* ↓　textbox → min/max */

//-] 関数数値範囲での絞り込み

tblcontrol.refine = function(event) {
  event.preventDefault();

  const form = event.target;
  const th = form.closest("th");
  const colIndex = th.cellIndex;
  const rows = th.closest("table").tBodies[0].rows;

  // 絞り込み条件取得（意味保証された属性から）
  const controlValue = th.dataset.control ?? "";
  const isNumber = controlValue.split(/\s+/).includes("number");
//  console.log(controlValue, isNumber, th.dataset.control); // ← デバッグ用

  const min = isNumber ? parseFloat(form.min?.value) : undefined;
  const max = isNumber ? parseFloat(form.max?.value) : undefined;
  const keyword = form.filter_keyword?.value?.trim();

  // keyitem（チェックボックス）取得
  const keyitem = form.filter_item
    ? Array.from(form.filter_item).filter(input => input.checked).map(input => input.value)
    : [];
  form.dataset.keyitem = JSON.stringify(keyitem);

  // 行ごとに絞り込み判定
  for (const row of rows) {
    const cell = row.cells[colIndex];
    const text = cell.textContent.trim();
    let show = true;

  // チェックボックスによる絞り込み
    if (keyitem.length > 0 && !keyitem.includes(text)) {
    show = false;
  }

    if (isNumber) {
      const value = parseFloat(text);
      if (!isNaN(min) && value < min) show = false;
      if (!isNaN(max) && value >= max) show = false;

      // キーワードでの数値絞り込み完全一致
      if (keyword && text !== keyword) show = false;
    } else {
      // キーワードでの文字列絞り込み部分一致
      if (keyword && !text.includes(keyword)) show = false;
    }

    row.style.display = show ? "" : "none";
  }
};

/* ── 関数：絞込み解除 ── */
tblcontrol.unrefine = evt => {
const filter = evt.target;
filter.filter_all.checked = true;
Array.from( filter.filter_item ).forEach( item => item.checked = true );
filter.filter_keyword.value = "";

/* ↓　textbox → min/max 2025-08-17*/
filter.min.value = "";
filter.max.value = "";
/* ↑　textbox → min/max */

tblcontrol.refine( evt );
};

/* ── tsv読み込み以前：全レコードhtml記述時代の旧・実装 ── */
// tblcontrol.init()は最初のrequestAnimationFrame()の中で呼び出される事となった。
// window.addEventListener( "DOMContentLoaded", tblcontrol.init, false );
</script>
</body>
</html>